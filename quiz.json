[
    {
        "subject": "C++ (S1-3: Intro & Basics)",
        "question": "Which of the following statements about C++ is FALSE?",
        "options": [
            "C++ supports procedural, object-oriented, and generic programming.",
            "C++ was originally named 'C with Classes'.",
            "The 'cin' and 'cout' objects require the <stdio.h> header.",
            "A key feature of C++ is its support for classes and objects."
        ],
        "reasons": [
            "Incorrect. This statement is true. C++ is a multi-paradigm language.",
            "Incorrect. This statement is true. Bjarne Stroustrup initially called it 'C with Classes'.",
            "Correct. This statement is false. `cin` and `cout` are part of the iostream library and require the `<iostream>` header.",
            "Incorrect. This statement is true and is the cornerstone of OOP in C++."
        ],
        "correctAnswer": 2
    },
    {
        "subject": "C++ (S2-3: Tokens, Members, Ops)",
        "question": "What is the output of the following C++ code snippet? \n`int x = 5; \nint y = ++x * x++; \nstd::cout << y;`",
        "options": [
            "30",
            "36",
            "25",
            "The behavior is undefined."
        ],
        "reasons": [
            "Incorrect. This would be the result of `6 * 5`.",
            "Incorrect. This would be the result of `6 * 6`.",
            "Incorrect. This would be the result of `5 * 5`.",
            "Correct. The C++ standard does not define the order of evaluation for the pre-increment and post-increment operators within the same expression when applied to the same variable. Modifying a variable more than once between sequence points results in undefined behavior. The compiler is free to evaluate `++x` or `x++` first, leading to different and unpredictable results."
        ],
        "correctAnswer": 3
    },
    {
        "subject": "C++ (S2-3: Static Members)",
        "question": "Consider a class `Counter`. How would you correctly initialize its static integer member `count` to 0?",
        "options": [
            "In the constructor: `Counter() { count = 0; }`",
            "Inside the class definition: `class Counter { static int count = 0; };`",
            "Outside the class definition: `int Counter::count = 0;`",
            "During object creation: `Counter c(0);`"
        ],
        "reasons": [
            "Incorrect. While this would work, it would re-initialize the shared static member to 0 every time a new object is created, which is usually not the intended behavior.",
            "Incorrect. Non-const static members cannot be initialized inside the class definition (prior to C++17 for integral types).",
            "Correct. Static data members must be defined and initialized once, typically in the source file (.cpp), outside the class definition, to allocate storage for them.",
            "Incorrect. This would imply passing an argument to a constructor, not initializing a static member."
        ],
        "correctAnswer": 2
    },
    {
        "subject": "C++ (S4: Loops & Conditionals)",
        "question": "What will be printed by the following code? \n`int a[] = {1,2,3,4,5}; \nfor(int i=0; i<5; i++) { \n  if(a[i] == 3) break; \n  std::cout << a[i]; \n}`",
        "options": [
            "12",
            "1245",
            "123",
            "12345"
        ],
        "reasons": [
            "Correct. The loop prints `1`, then `2`. When `a[i]` (which is 3) is encountered, the `if` condition becomes true, and the `break` statement immediately terminates the `for` loop.",
            "Incorrect. This would be the output if `continue` were used instead of `break`.",
            "Incorrect. The `cout` statement is after the `break` condition, so 3 is never printed.",
            "Incorrect. The `break` statement prevents the loop from completing all its iterations."
        ],
        "correctAnswer": 0
    },
    {
        "subject": "C++ (S4: Arrays)",
        "question": "What is a potential issue with the following code? \n`int arr[5]; \nstd::cout << arr[5];`",
        "options": [
            "It will always print 0.",
            "It will cause a compile-time error.",
            "It accesses memory outside the bounds of the array, leading to undefined behavior.",
            "It will safely print the last element of the array."
        ],
        "reasons": [
            "Incorrect. Uninitialized local arrays contain garbage values, not necessarily 0.",
            "Incorrect. C++ does not perform bounds checking on arrays at compile time, so this code will compile without errors.",
            "Correct. An array `arr[5]` has valid indices from 0 to 4. Accessing `arr[5]` is an out-of-bounds access. This results in undefined behavior, which could be a crash, reading a garbage value, or corrupting other data.",
            "Incorrect. The last element of the array is at index 4, not 5."
        ],
        "correctAnswer": 2
    },
    {
        "subject": "C++ (S5: Functions)",
        "question": "What is the output of this code snippet demonstrating call-by-reference? \n`void modify(int &x) { x = x * 2; } \nint main() { \n  int a = 10; \n  modify(a); \n  std::cout << a; \n  return 0; \n}`",
        "options": [
            "10",
            "20",
            "A random garbage value.",
            "A compile-time error."
        ],
        "reasons": [
            "Incorrect. This would be the output if the function used call-by-value (`void modify(int x)`).",
            "Correct. The function `modify` takes its argument by reference (`int &x`). This means `x` becomes an alias for the variable `a` passed from `main`. Any changes made to `x` inside the function directly affect the original variable `a`.",
            "Incorrect. The behavior is well-defined.",
            "Incorrect. The code is syntactically correct."
        ],
        "correctAnswer": 1
    },
    {
        "subject": "C++ (S6-7: Pointers & Memory)",
        "question": "What is the correct way to deallocate memory for an array allocated with `int* p = new int[10];`?",
        "options": [
            "`delete p;`",
            "`delete[] p;`",
            "`free(p);`",
            "The memory is automatically deallocated when p goes out of scope."
        ],
        "reasons": [
            "Incorrect. Using `delete` on an array allocated with `new[]` results in undefined behavior. It will likely only call the destructor for the first element and leak the rest.",
            "Correct. Memory allocated with the array form `new[]` MUST be deallocated with the array form `delete[]`. This ensures that the destructors for all elements in the array are called and all memory is properly freed.",
            "Incorrect. `free()` is the C-style deallocation function and should only be used with memory allocated by `malloc()`, `calloc()`, or `realloc()`. Mixing `new[]` and `free()` is undefined behavior.",
            "Incorrect. Memory allocated on the heap with `new` or `new[]` is not automatically managed. It must be explicitly deallocated by the programmer."
        ],
        "correctAnswer": 1
    },
    {
        "subject": "C++ (S6-7: 'this' pointer)",
        "question": "What does the `this` pointer represent inside a C++ member function?",
        "options": [
            "A pointer to the base class of the current object.",
            "A pointer to the derived class of the current object.",
            "A pointer to the specific object that called the member function.",
            "A pointer to the static members of the class."
        ],
        "reasons": [
            "Incorrect. It points to the current object, not specifically its base class.",
            "Incorrect. It points to the current object, not specifically its derived class.",
            "Correct. `this` is a keyword that holds the memory address of the current object. It allows the member function to know which object's data members it should be operating on. It's implicitly passed to every non-static member function.",
            "Incorrect. Static members are not associated with any specific object, so the `this` pointer cannot be used to access them and is not available in static member functions."
        ],
        "correctAnswer": 2
    },
    {
        "subject": "C++ (S8: OOP Concepts)",
        "question": "What is encapsulation in Object-Oriented Programming?",
        "options": [
            "The ability of an object to take on many forms.",
            "The process of creating a new class from an existing class.",
            "The bundling of data (attributes) and the methods that operate on that data into a single unit (a class).",
            "The mechanism of hiding the implementation details of a class and exposing only the necessary functionality."
        ],
        "reasons": [
            "Incorrect. This describes polymorphism.",
            "Incorrect. This describes inheritance.",
            "Correct. Encapsulation is the concept of wrapping data and the functions that manipulate it together. A class is the primary mechanism for encapsulation in C++.",
            "Incorrect. While closely related and often a result of good encapsulation, this more accurately describes data hiding or abstraction."
        ],
        "correctAnswer": 2
    },
    {
        "subject": "C++ (S9: Constructors/Destructors)",
        "question": "When is a destructor for an object automatically called?",
        "options": [
            "Only when `delete` is explicitly called on the object's pointer.",
            "When the object, created on the stack, goes out of scope.",
            "When a pointer to an object allocated on the heap goes out of scope.",
            "Both A and B are correct."
        ],
        "reasons": [
            "Partially correct, but not the only case. This is true for heap-allocated objects.",
            "Partially correct, but not the only case. This is true for stack-allocated objects.",
            "Incorrect. When the pointer goes out of scope, only the memory for the pointer itself is freed. The heap memory it points to is leaked unless `delete` is called.",
            "Correct. The destructor is called automatically for stack-allocated (automatic) objects when their scope ends. For heap-allocated objects, the destructor is called when `delete` (or `delete[]`) is used on a pointer to that object."
        ],
        "correctAnswer": 3
    },
    {
        "subject": "C++ (S10: Inheritance)",
        "question": "What is the order of constructor and destructor calls for an object of a derived class?",
        "options": [
            "Base constructor -> Derived constructor -> Base destructor -> Derived destructor",
            "Derived constructor -> Base constructor -> Derived destructor -> Base destructor",
            "Base constructor -> Derived constructor -> Derived destructor -> Base destructor",
            "Derived constructor -> Base constructor -> Base destructor -> Derived destructor"
        ],
        "reasons": [
            "Incorrect. The destructor order is wrong.",
            "Incorrect. The constructor order is wrong.",
            "Correct. Construction happens from the 'base' up: the base class must be fully constructed before the derived part can be. Destruction happens in the reverse order, from the 'derived' down: the derived part is destroyed first, then the base part is destroyed.",
            "Incorrect. Both the constructor and destructor orders are wrong."
        ],
        "correctAnswer": 2
    },
    {
        "subject": "C++ (S11: Polymorphism)",
        "question": "Which of the following is an example of compile-time (static) polymorphism?",
        "options": [
            "Virtual functions",
            "Function overloading",
            "Pure virtual functions",
            "Using `dynamic_cast`"
        ],
        "reasons": [
            "Incorrect. Virtual functions are the primary mechanism for run-time (dynamic) polymorphism.",
            "Correct. Function overloading allows multiple functions with the same name but different parameters. The compiler resolves which function to call at compile-time based on the arguments provided. This is static polymorphism because the decision is made before the program runs.",
            "Incorrect. Pure virtual functions are a special type of virtual function used for run-time polymorphism and defining abstract classes.",
            "Incorrect. `dynamic_cast` is a tool used in the context of run-time polymorphism."
        ],
        "correctAnswer": 1
    },
    {
        "subject": "C++ (S12: Virtual & Abstract)",
        "question": "What is the primary effect of declaring a class method as a pure virtual function (e.g., `virtual void draw() = 0;`)?",
        "options": [
            "It forces all derived classes to be named `Pure`.",
            "It makes the class an abstract class, which cannot be instantiated.",
            "It provides a default implementation that logs a message.",
            "It prevents the function from being called through a base class pointer."
        ],
        "reasons": [
            "Incorrect. This is nonsensical.",
            "Correct. A class that contains one or more pure virtual functions is known as an abstract class. The compiler will not allow you to create an object of an abstract class directly. Its purpose is to serve as an interface that concrete derived classes must implement.",
            "Incorrect. A pure virtual function has no implementation in the base class by definition.",
            "Incorrect. The primary purpose of this mechanism is to allow the function to be called polymorphically through a base class pointer, which will then execute the derived class's implementation."
        ],
        "correctAnswer": 1
    },
    {
        "subject": "C++ (S13: Exception Handling)",
        "question": "What happens if an exception is thrown inside a function but is not caught by any `catch` block within that function?",
        "options": [
            "The program crashes immediately.",
            "The exception is ignored, and the program continues normally.",
            "The exception propagates up the call stack to the calling function, searching for a suitable `catch` block there.",
            "It results in a compile-time error."
        ],
        "reasons": [
            "Incorrect. It doesn't crash immediately unless it reaches the top of the call stack without being caught.",
            "Incorrect. Exceptions are never ignored by default.",
            "Correct. This process is called stack unwinding. If a function doesn't handle an exception, its stack frame is destroyed, and the exception is passed to the function that called it. This continues until a matching `catch` block is found or until it reaches `main()`. If not caught by `main()`, the program terminates.",
            "Incorrect. Exception handling is a run-time mechanism. The compiler cannot know if an exception will be thrown or caught."
        ],
        "correctAnswer": 2
    },
    {
        "subject": "C++ (S14: I/O Streams)",
        "question": "What is the purpose of `std::endl` besides inserting a newline character?",
        "options": [
            "It converts the output to a wide character string.",
            "It has no other purpose; it is identical to outputting '\\n'.",
            "It also flushes the output buffer, ensuring the output is immediately written to its destination.",
            "It signals the end of the entire program."
        ],
        "reasons": [
            "Incorrect. This is unrelated to `std::endl`'s function.",
            "Incorrect. This is a common misconception. There is a critical difference related to buffering.",
            "Correct. `std::cout` is a buffered stream. Output isn't always written immediately. `std::endl` inserts a newline character (`'\\n'`) and then explicitly calls `flush()` on the stream. This can have performance implications, and using just `'\\n'` is often faster if an immediate flush is not required.",
            "Incorrect. The program ends when `main` returns or `exit()` is called."
        ],
        "correctAnswer": 2
    },
    {
        "subject": "C++ (S15: File Handling)",
        "question": "Which of the following correctly opens a file named 'data.txt' for both reading and writing?",
        "options": [
            "`std::fstream file(\"data.txt\", std::ios::in);`",
            "`std::fstream file(\"data.txt\", std::ios::out);`",
            "`std::fstream file(\"data.txt\", std::ios::in | std::ios::out);`",
            "`std::fstream file(\"data.txt\", std::ios::app);`"
        ],
        "reasons": [
            "Incorrect. This opens the file for input (reading) only.",
            "Incorrect. This opens the file for output (writing) only.",
            "Correct. The `fstream` class can handle both input and output. The I/O mode flags can be combined using the bitwise OR operator (`|`). `std::ios::in | std::ios::out` specifies that the file should be opened for both reading and writing.",
            "Incorrect. `std::ios::app` opens the file in append mode, where all output operations are written to the end of the file."
        ],
        "correctAnswer": 2
    },
    {
        "subject": "C++ (S16: Templates)",
        "question": "What is the primary advantage of using class templates in C++?",
        "options": [
            "To reduce the runtime of the program.",
            "To write generic classes that can work with any data type, reducing code duplication.",
            "To enforce that a class can only be used with integer types.",
            "To automatically create constructors and destructors for a class."
        ],
        "reasons": [
            "Incorrect. Templates can sometimes increase compile time and do not directly reduce runtime.",
            "Correct. Class templates allow you to define a blueprint for a class. You can then create specific instances of that class for different data types (e.g., `Stack<int>`, `Stack<double>`, `Stack<string>`) without having to rewrite the entire class logic for each type.",
            "Incorrect. This is the opposite of the purpose of templates, which is to be generic.",
            "Incorrect. Templates do not automatically create constructors/destructors, though you define them within the template itself."
        ],
        "correctAnswer": 1
    },
    {
        "subject": "C++ (S17-18: STL)",
        "question": "Which STL container provides fast insertion and deletion at both the beginning and the end of the sequence?",
        "options": [
            "`std::vector`",
            "`std::map`",
            "`std::list`",
            "`std::stack`"
        ],
        "reasons": [
            "Incorrect. `std::vector` provides fast (amortized constant time) insertion at the end, but insertion at the beginning is very slow (linear time, O(n)) because all subsequent elements must be shifted.",
            "Incorrect. `std::map` is a sorted associative container, not a sequence container. Its performance is based on key lookups, not positions.",
            "Correct. `std::list` is a doubly-linked list. Because it stores elements in non-contiguous nodes with pointers to the next and previous nodes, insertion or deletion at any point (including the beginning and end) is a fast constant time operation (O(1)), provided you have an iterator to the position.",
            "Incorrect. `std::stack` is a container adapter that only allows insertion and deletion at one end (the top)."
        ],
        "correctAnswer": 2
    },
    {
        "subject": "C++ (S17-18: RTTI)",
        "question": "What is the purpose of `dynamic_cast` in C++?",
        "options": [
            "To cast away the `const`-ness of a variable.",
            "To perform a type-safe downcast of a pointer or reference within a class hierarchy.",
            "To perform any type of cast at compile-time with minimal safety checks.",
            "To reinterpret the bit pattern of a pointer as a different type."
        ],
        "reasons": [
            "Incorrect. This is the purpose of `const_cast`.",
            "Correct. `dynamic_cast` is used for navigating inheritance hierarchies at runtime. It is primarily used to safely convert a base class pointer/reference to a derived class pointer/reference. If the cast is not possible (i.e., the object is not actually of the target derived type), it returns `nullptr` for pointers or throws a `std::bad_cast` exception for references. It requires the base class to be polymorphic (have at least one virtual function).",
            "Incorrect. This describes `static_cast` (for related types) or C-style casts.",
            "Incorrect. This is the purpose of `reinterpret_cast`."
        ],
        "correctAnswer": 1
    }
]